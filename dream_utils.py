import whisper
import requests
import os
import json
import re
from datetime import datetime
from dotenv import load_dotenv
from typing import Dict, List, Any

load_dotenv()

# Configuration des mod√®les
whisper_model = whisper.load_model("base")

# Fichier de stockage des r√™ves
DREAMS_FILE = "dreams_history.json"

def transcribe_audio(audio_path: str) -> str:
    """Transcrit un fichier audio en texte"""
    try:
        result = whisper_model.transcribe(audio_path, language="fr")
        return result["text"]
    except Exception as e:
        raise Exception(f"Erreur lors de la transcription : {str(e)}")

def generate_image(prompt: str) -> str:
    """G√©n√®re une image √† partir d'un prompt"""
    api_key = os.getenv("CLIPDROP_API_KEY")
    if not api_key:
        raise Exception("La cl√© API Clipdrop n'est pas d√©finie dans .env")
    
    # Am√©lioration du prompt pour de meilleures images
    enhanced_prompt = f"dream interpretation, surreal, mystical, {prompt}, high quality, detailed, artistic"
    
    url = "https://clipdrop-api.co/text-to-image/v1"
    
    try:
        response = requests.post(
            url,
            headers={"x-api-key": api_key},
            json={
                "prompt": enhanced_prompt,
                
            }
        )
        
        if response.status_code == 200:
            # Nom de fichier unique
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"dream_image_{timestamp}.png"
            
            with open(filename, "wb") as f:
                f.write(response.content)
            return filename
        else:
            raise Exception(f"Erreur g√©n√©ration image : {response.status_code}, {response.text}")
    except Exception as e:
        raise Exception(f"Erreur lors de la g√©n√©ration d'image : {str(e)}")

def analyze_dream(dream_text: str) -> Dict[str, Any]:
    """Analyse un r√™ve et retourne une interpr√©tation compl√®te"""
    
    # Dictionnaire √©tendu des symboles de r√™ve
    dream_symbols = {
        "eau": "√©motions, inconscient, purification, fluidit√©",
        "feu": "passion, transformation, √©nergie, destruction cr√©atrice",
        "voler": "libert√©, √©vasion, aspiration, d√©passement de soi",
        "chute": "perte de contr√¥le, anxi√©t√©, peur de l'√©chec",
        "animal": "instincts, nature primitive, aspects refoul√©s",
        "maison": "soi, psych√©, s√©curit√©, intimit√©",
        "mort": "transformation, fin d'un cycle, renaissance",
        "enfant": "innocence, nouveau d√©part, potentiel",
        "serpent": "transformation, sagesse cach√©e, gu√©rison",
        "chat": "ind√©pendance, myst√®re, intuition f√©minine",
        "chien": "loyaut√©, amiti√©, protection, fid√©lit√©",
        "arbre": "croissance, stabilit√©, connexion terre-ciel",
        "montagne": "d√©fi, objectif, √©l√©vation spirituelle",
        "oc√©an": "inconscient collectif, immensit√©, √©motions profondes",
        "lumi√®re": "connaissance, espoir, r√©v√©lation, clart√©",
        "obscurit√©": "inconnu, peur, myst√®re, potentiel cach√©",
        "pont": "transition, connexion, passage",
        "escalier": "progression, √©volution, ascension",
        "miroir": "introspection, v√©rit√©, conscience de soi",
        "cl√©": "solution, acc√®s, r√©v√©lation, pouvoir",
        "porte": "opportunit√©, passage, choix, seuil",
        "voiture": "contr√¥le, direction de vie, autonomie",
        "avion": "ambitions √©lev√©es, perspective, voyage spirituel",
        "√©cole": "apprentissage, √©valuation, retour au pass√©",
        "h√¥pital": "gu√©rison, vuln√©rabilit√©, besoin de soins",
        "nourriture": "besoins fondamentaux, nourriture spirituelle",
        "argent": "valeur personnelle, s√©curit√©, pouvoir",
        "bijoux": "valeur cach√©e, beaut√© int√©rieure, pr√©ciosit√©",
        "livre": "connaissance, sagesse, recherche de v√©rit√©",
        "t√©l√©phone": "communication, besoin de connexion",
        "b√©b√©": "nouveau projet, vuln√©rabilit√©, responsabilit√©"
    }
    
    # Analyse des symboles pr√©sents
    symbols_found = []
    dream_lower = dream_text.lower()
    
    for symbol, meaning in dream_symbols.items():
        if symbol in dream_lower:
            symbols_found.append(symbol)
    
    # Analyse des √©motions √©tendues
    emotion_words = {
        "peur": ["peur", "effray√©", "terrifi√©", "anxieux", "angoiss√©", "inquiet", "paniqu√©"],
        "joie": ["heureux", "joyeux", "content", "ravi", "euphorie", "d√©lice", "bonheur"],
        "tristesse": ["triste", "m√©lancolique", "d√©prim√©", "chagrin", "peine", "m√©lancolie"],
        "col√®re": ["col√®re", "furieux", "irrit√©", "rage", "√©nerv√©", "agac√©", "indign√©"],
        "surprise": ["surpris", "√©tonn√©", "choqu√©", "stup√©fait", "sid√©r√©", "√©bahi"],
        "s√©r√©nit√©": ["calme", "paisible", "serein", "tranquille", "apais√©", "zen"],
        "amour": ["amour", "tendresse", "affection", "passion", "attachement"],
        "nostalgie": ["nostalgie", "m√©lancolie", "regret", "souvenir", "pass√©"],
        "confusion": ["confus", "perdu", "d√©boussol√©", "d√©sorient√©", "trouble"],
        "excitation": ["excit√©", "stimul√©", "enthousiaste", "f√©brile", "survolt√©"]
    }
    
    emotions_detected = []
    for emotion, words in emotion_words.items():
        if any(word in dream_lower for word in words):
            emotions_detected.append(emotion)
    
    # G√©n√©ration d'une interpr√©tation riche
    interpretation = generate_comprehensive_interpretation(dream_text, symbols_found, emotions_detected)
    
    return {
        "interpretation": interpretation,
        "symbols": symbols_found,
        "emotions": emotions_detected,
        "word_count": len(dream_text.split()),
        "complexity_score": calculate_complexity_score(dream_text),
        "themes": identify_dream_themes(dream_text, symbols_found),
        "psychological_insights": generate_psychological_insights(symbols_found, emotions_detected)
    }

def generate_comprehensive_interpretation(dream_text: str, symbols: List[str], emotions: List[str]) -> str:
    """G√©n√®re une interpr√©tation compl√®te et riche du r√™ve"""
    
    interpretation_parts = []
    
    # Introduction personnalis√©e
    if emotions:
        dominant_emotion = emotions[0]
        if dominant_emotion == "peur":
            interpretation_parts.append("Votre r√™ve semble refl√©ter des pr√©occupations ou anxi√©t√©s actuelles.")
        elif dominant_emotion == "joie":
            interpretation_parts.append("Ce r√™ve r√©v√®le un √©tat d'esprit positif et optimiste.")
        elif dominant_emotion == "tristesse":
            interpretation_parts.append("Votre r√™ve exprime peut-√™tre un besoin de gu√©rison √©motionnelle.")
        else:
            interpretation_parts.append("Votre r√™ve r√©v√®le une riche palette d'√©motions √† explorer.")
    else:
        interpretation_parts.append("Votre r√™ve offre des insights fascinants sur votre monde int√©rieur.")
    
    # Analyse approfondie des symboles
    if symbols:
        interpretation_parts.append(f"\nüîÆ **Symboles identifi√©s** : {', '.join(symbols)}")
        
        # Analyse sp√©cifique par symbole
        for symbol in symbols[:3]:  # Limiter aux 3 premiers pour √©viter la surcharge
            if symbol == "eau":
                interpretation_parts.append("‚Ä¢ L'eau repr√©sente vos √©motions profondes et votre capacit√© d'adaptation. Elle peut indiquer un besoin de purification ou de renouveau √©motionnel.")
            elif symbol == "voler":
                interpretation_parts.append("‚Ä¢ Le vol symbolise votre d√©sir de libert√© et d'√©vasion. Vous aspirez peut-√™tre √† d√©passer vos limitations actuelles.")
            elif symbol == "maison":
                interpretation_parts.append("‚Ä¢ La maison refl√®te votre √©tat psychologique intime. Elle peut r√©v√©ler comment vous vous sentez en s√©curit√© ou non dans votre vie.")
            elif symbol == "animal":
                interpretation_parts.append("‚Ä¢ Les animaux dans vos r√™ves repr√©sentent vos instincts naturels et vos aspects les plus authentiques.")
            elif symbol == "mort":
                interpretation_parts.append("‚Ä¢ La mort symbolise une transformation profonde, la fin d'une p√©riode et le d√©but d'une nouvelle phase de vie.")
            elif symbol == "lumi√®re":
                interpretation_parts.append("‚Ä¢ La lumi√®re repr√©sente la connaissance, l'espoir et la clart√© qui √©mergent dans votre conscience.")
            elif symbol == "obscurit√©":
                interpretation_parts.append("‚Ä¢ L'obscurit√© peut symboliser l'inconnu qui vous intrigue ou des aspects de vous-m√™me √† explorer.")
    
    # Analyse des √©motions
    if emotions:
        interpretation_parts.append(f"\nüí≠ **Climat √©motionnel** : {', '.join(emotions)}")
        
        if "peur" in emotions and "joie" in emotions:
            interpretation_parts.append("‚Ä¢ Le m√©lange de peur et de joie sugg√®re une p√©riode de transition o√π excitation et appr√©hension coexistent.")
        elif "peur" in emotions:
            interpretation_parts.append("‚Ä¢ La peur pr√©sente peut refl√©ter des anxi√©t√©s actuelles ou anticiper des d√©fis √† venir.")
        elif "joie" in emotions:
            interpretation_parts.append("‚Ä¢ Les sentiments positifs indiquent un alignement avec vos valeurs profondes et vos aspirations.")
        elif "tristesse" in emotions:
            interpretation_parts.append("‚Ä¢ La tristesse peut signaler un besoin de gu√©rison ou d'acceptation d'une perte.")
        
        if "s√©r√©nit√©" in emotions:
            interpretation_parts.append("‚Ä¢ La s√©r√©nit√© sugg√®re que vous trouvez un √©quilibre int√©rieur malgr√© les d√©fis.")
    
    # Analyse des patterns narratifs
    dream_lower = dream_text.lower()
    
    # Analyse du mouvement dans le r√™ve
    if any(word in dream_lower for word in ["course", "courir", "fuite", "poursuivre"]):
        interpretation_parts.append("\nüèÉ **Dynamique de mouvement** : Le th√®me de la course ou de la fuite sugg√®re un d√©sir d'√©chapper √† une situation ou au contraire de poursuivre un objectif.")
    
    if any(word in dream_lower for word in ["chute", "tomber", "glisser"]):
        interpretation_parts.append("\n‚¨áÔ∏è **Dynamique de chute** : La chute peut repr√©senter une perte de contr√¥le ou la peur d'√©chouer dans un domaine important.")
    
    # Analyse des relations dans le r√™ve
    if any(word in dream_lower for word in ["famille", "m√®re", "p√®re", "enfant", "fr√®re", "s≈ìur"]):
        interpretation_parts.append("\nüë®‚Äçüë©‚Äçüëß‚Äçüë¶ **Dimension familiale** : La pr√©sence de la famille sugg√®re des questions li√©es √† vos racines, votre identit√© ou vos relations proches.")
    
    if any(word in dream_lower for word in ["ami", "amour", "couple", "partenaire"]):
        interpretation_parts.append("\nüíï **Dimension relationnelle** : Les relations dans votre r√™ve refl√®tent vos besoins de connexion et d'intimit√©.")
    
    # Conseils et perspectives
    interpretation_parts.append("\n‚ú® **Perspectives** :")
    
    if symbols and emotions:
        if "eau" in symbols and "s√©r√©nit√©" in emotions:
            interpretation_parts.append("‚Ä¢ Votre r√™ve sugg√®re une p√©riode propice √† l'introspection et √† la gu√©rison √©motionnelle.")
        elif "voler" in symbols and "joie" in emotions:
            interpretation_parts.append("‚Ä¢ C'est peut-√™tre le moment d'oser prendre des risques cr√©atifs ou professionnels.")
        elif "maison" in symbols and "peur" in emotions:
            interpretation_parts.append("‚Ä¢ Explorez ce qui vous fait vous sentir en s√©curit√© ou vuln√©rable dans votre environnement actuel.")
        else:
            interpretation_parts.append("‚Ä¢ Consid√©rez ce r√™ve comme une invitation √† explorer les aspects de votre vie qu'il met en lumi√®re.")
    
    interpretation_parts.append("‚Ä¢ Gardez un journal de vos r√™ves pour identifier des patterns r√©currents.")
    interpretation_parts.append("‚Ä¢ M√©ditez sur les √©motions ressenties pour mieux comprendre leurs messages.")
    
    return "\n".join(interpretation_parts)

def identify_dream_themes(dream_text: str, symbols: List[str]) -> List[str]:
    """Identifie les th√®mes principaux du r√™ve"""
    
    themes = []
    dream_lower = dream_text.lower()
    
    # Th√®mes bas√©s sur les symboles
    transformation_symbols = ["mort", "serpent", "feu", "eau", "papillon"]
    if any(symbol in symbols for symbol in transformation_symbols):
        themes.append("Transformation")
    
    freedom_symbols = ["voler", "oiseau", "ciel", "montagne"]
    if any(symbol in symbols for symbol in freedom_symbols):
        themes.append("Libert√©")
    
    security_symbols = ["maison", "famille", "enfant", "cocon"]
    if any(symbol in symbols for symbol in security_symbols):
        themes.append("S√©curit√©")
    
    # Th√®mes bas√©s sur le contenu textuel
    if any(word in dream_lower for word in ["travail", "bureau", "coll√®gue", "patron"]):
        themes.append("Vie professionnelle")
    
    if any(word in dream_lower for word in ["amour", "couple", "mariage", "baiser"]):
        themes.append("Relations amoureuses")
    
    if any(word in dream_lower for word in ["√©cole", "examen", "√©tude", "apprendre"]):
        themes.append("Apprentissage")
    
    if any(word in dream_lower for word in ["voyage", "partir", "route", "destination"]):
        themes.append("Voyage/Qu√™te")
    
    if any(word in dream_lower for word in ["pass√©", "enfance", "souvenir", "nostalgie"]):
        themes.append("Pass√©/M√©moire")
    
    return themes

def generate_psychological_insights(symbols: List[str], emotions: List[str]) -> List[str]:
    """G√©n√®re des insights psychologiques bas√©s sur les symboles et √©motions"""
    
    insights = []
    
    # Insights bas√©s sur les combinaisons symboles/√©motions
    if "eau" in symbols and "peur" in emotions:
        insights.append("Possible anxi√©t√© face √† vos √©motions profondes")
    
    if "voler" in symbols and "joie" in emotions:
        insights.append("Forte aspiration √† la libert√© et √† l'accomplissement")
    
    if "maison" in symbols and "s√©r√©nit√©" in emotions:
        insights.append("Sentiment de s√©curit√© int√©rieure bien √©tabli")
    
    if "mort" in symbols and "tristesse" in emotions:
        insights.append("Processus de deuil ou acceptation d'un changement")
    
    # Insights bas√©s sur les √©motions multiples
    if len(emotions) > 2:
        insights.append("Richesse √©motionnelle complexe n√©cessitant de l'attention")
    
    if "peur" in emotions and "joie" in emotions:
        insights.append("Ambivalence face √† une situation de changement")
    
    # Insights bas√©s sur les symboles
    if len(symbols) > 3:
        insights.append("R√™ve riche en symboles indiquant une p√©riode de transformation")
    
    if "lumi√®re" in symbols and "obscurit√©" in symbols:
        insights.append("Processus d'int√©gration entre conscient et inconscient")
    
    return insights

def calculate_complexity_score(dream_text: str) -> float:
    """Calcule un score de complexit√© du r√™ve"""
    
    # Facteurs de complexit√©
    word_count = len(dream_text.split())
    sentence_count = len(re.split(r'[.!?]+', dream_text))
    
    # Pr√©sence de mots complexes
    complex_words = ["transformation", "m√©tamorphose", "symbolique", "myst√©rieux", "surr√©aliste"]
    complex_word_count = sum(1 for word in complex_words if word in dream_text.lower())
    
    # Score bas√© sur diff√©rents crit√®res
    length_score = min(word_count / 100, 1.0)  # Normalis√© sur 100 mots
    structure_score = min(sentence_count / 10, 1.0)  # Normalis√© sur 10 phrases
    complexity_word_score = min(complex_word_count / 5, 1.0)  # Normalis√© sur 5 mots complexes
    
    final_score = (length_score + structure_score + complexity_word_score) / 3
    return round(final_score * 10, 1)  # Score sur 10

def save_dream_entry(dream_entry: Dict[str, Any]):
    """Sauvegarde une entr√©e de r√™ve dans le fichier JSON"""
    
    # Charger l'historique existant
    history = load_dream_history()
    
    # Ajouter la nouvelle entr√©e
    history.append(dream_entry)
    
    # Sauvegarder
    try:
        with open(DREAMS_FILE, 'w', encoding='utf-8') as f:
            json.dump(history, f, ensure_ascii=False, indent=2)
    except Exception as e:
        raise Exception(f"Erreur lors de la sauvegarde : {str(e)}")

def load_dream_history() -> List[Dict[str, Any]]:
    """Charge l'historique des r√™ves depuis le fichier JSON"""
    
    if not os.path.exists(DREAMS_FILE):
        return []
    
    try:
        with open(DREAMS_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        print(f"Erreur lors du chargement de l'historique : {str(e)}")
        return []

def get_dream_statistics() -> Dict[str, Any]:
    """Calcule des statistiques sur les r√™ves enregistr√©s"""
    
    history = load_dream_history()
    
    if not history:
        return {}
    
    # Statistiques de base
    total_dreams = len(history)
    
    # Qualit√© moyenne du sommeil
    sleep_qualities = [d["metadata"].get("sleep_quality", 0) for d in history if d["metadata"].get("sleep_quality")]
    avg_sleep_quality = sum(sleep_qualities) / len(sleep_qualities) if sleep_qualities else 0
    
    # Clart√© moyenne des r√™ves
    dream_clarities = [d["metadata"].get("dream_clarity", 0) for d in history if d["metadata"].get("dream_clarity")]
    avg_dream_clarity = sum(dream_clarities) / len(dream_clarities) if dream_clarities else 0
    
    # Types de r√™ves les plus fr√©quents
    dream_types = [d["metadata"].get("dream_type", "Non sp√©cifi√©") for d in history]
    type_counts = {}
    for dream_type in dream_types:
        type_counts[dream_type] = type_counts.get(dream_type, 0) + 1
    
    # √âmotions les plus fr√©quentes
    all_emotions = []
    for d in history:
        all_emotions.extend(d["metadata"].get("emotions", []))
    
    emotion_counts = {}
    for emotion in all_emotions:
        emotion_counts[emotion] = emotion_counts.get(emotion, 0) + 1
    
    # Symboles les plus fr√©quents
    all_symbols = []
    for d in history:
        all_symbols.extend(d["analysis"].get("symbols", []))
    
    symbol_counts = {}
    for symbol in all_symbols:
        symbol_counts[symbol] = symbol_counts.get(symbol, 0) + 1
    
    # √âvolution dans le temps
    dates = [datetime.fromisoformat(d["date"]) for d in history]
    first_dream = min(dates) if dates else None
    last_dream = max(dates) if dates else None
    
    # Score de complexit√© moyen
    complexity_scores = [d["analysis"].get("complexity_score", 0) for d in history]
    avg_complexity = sum(complexity_scores) / len(complexity_scores) if complexity_scores else 0
    
    return {
        "total_dreams": total_dreams,
        "avg_sleep_quality": round(avg_sleep_quality, 1),
        "avg_dream_clarity": round(avg_dream_clarity, 1),
        "avg_complexity": round(avg_complexity, 1),
        "dream_type_distribution": type_counts,
        "emotion_distribution": emotion_counts,
        "symbol_distribution": symbol_counts,
        "first_dream_date": first_dream.isoformat() if first_dream else None,
        "last_dream_date": last_dream.isoformat() if last_dream else None,
        "dream_frequency": calculate_dream_frequency(dates) if dates else 0
    }

def calculate_dream_frequency(dates: List[datetime]) -> float:
    """Calcule la fr√©quence des r√™ves (r√™ves par semaine)"""
    if len(dates) < 2:
        return 0
    
    # Calculer la p√©riode entre le premier et le dernier r√™ve
    period_days = (max(dates) - min(dates)).days
    
    if period_days == 0:
        return len(dates)  # Tous les r√™ves le m√™me jour
    
    # Convertir en semaines et calculer la fr√©quence
    period_weeks = period_days / 7
    return round(len(dates) / period_weeks, 1)

def search_dreams(query: str, dream_history: List[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
    """Recherche dans l'historique des r√™ves"""
    
    if dream_history is None:
        dream_history = load_dream_history()
    
    if not query.strip():
        return dream_history
    
    query_lower = query.lower()
    results = []
    
    for dream in dream_history:
        # Recherche dans le titre
        if query_lower in dream.get("title", "").lower():
            results.append(dream)
            continue
        
        # Recherche dans le texte du r√™ve
        if query_lower in dream.get("text", "").lower():
            results.append(dream)
            continue
        
        # Recherche dans les symboles
        symbols = dream.get("analysis", {}).get("symbols", [])
        if any(query_lower in symbol.lower() for symbol in symbols):
            results.append(dream)
            continue
        
        # Recherche dans les √©motions
        emotions = dream.get("metadata", {}).get("emotions", [])
        if any(query_lower in emotion.lower() for emotion in emotions):
            results.append(dream)
            continue
    
    return results

def export_dreams_to_json(filename: str = None) -> str:
    """Exporte tous les r√™ves vers un fichier JSON"""
    
    if filename is None:
        filename = f"dreams_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    
    history = load_dream_history()
    
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(history, f, ensure_ascii=False, indent=2)
        return filename
    except Exception as e:
        raise Exception(f"Erreur lors de l'export : {str(e)}")

def import_dreams_from_json(filename: str) -> int:
    """Importe des r√™ves depuis un fichier JSON"""
    
    if not os.path.exists(filename):
        raise Exception(f"Le fichier {filename} n'existe pas")
    
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            imported_dreams = json.load(f)
        
        # Valider la structure des donn√©es
        if not isinstance(imported_dreams, list):
            raise Exception("Le fichier doit contenir une liste de r√™ves")
        
        # Charger l'historique existant
        existing_history = load_dream_history()
        
        # √âviter les doublons bas√©s sur la date et le texte
        existing_keys = set()
        for dream in existing_history:
            key = (dream.get("date", ""), dream.get("text", "")[:50])
            existing_keys.add(key)
        
        # Ajouter les nouveaux r√™ves
        new_dreams = []
        for dream in imported_dreams:
            key = (dream.get("date", ""), dream.get("text", "")[:50])
            if key not in existing_keys:
                new_dreams.append(dream)
                existing_keys.add(key)
        
        # Sauvegarder l'historique mis √† jour
        updated_history = existing_history + new_dreams
        
        with open(DREAMS_FILE, 'w', encoding='utf-8') as f:
            json.dump(updated_history, f, ensure_ascii=False, indent=2)
        
        return len(new_dreams)
        
    except Exception as e:
        raise Exception(f"Erreur lors de l'import : {str(e)}")

def delete_dream(dream_index: int) -> bool:
    """Supprime un r√™ve de l'historique"""
    
    history = load_dream_history()
    
    if 0 <= dream_index < len(history):
        # Supprimer le fichier image associ√© si il existe
        dream = history[dream_index]
        image_path = dream.get("image_path", "")
        if image_path and os.path.exists(image_path):
            try:
                os.remove(image_path)
            except:
                pass  # Ignorer les erreurs de suppression d'image
        
        # Supprimer l'entr√©e
        history.pop(dream_index)
        
        # Sauvegarder
        try:
            with open(DREAMS_FILE, 'w', encoding='utf-8') as f:
                json.dump(history, f, ensure_ascii=False, indent=2)
            return True
        except Exception as e:
            raise Exception(f"Erreur lors de la suppression : {str(e)}")
    
    return False

def cleanup_old_images(days_old: int = 30):
    """Nettoie les images anciennes pour lib√©rer de l'espace"""
    
    cutoff_date = datetime.now().timestamp() - (days_old * 24 * 60 * 60)
    
    # Lister tous les fichiers d'images de r√™ves
    image_files = []
    for filename in os.listdir('.'):
        if filename.startswith('dream_image_') and filename.endswith('.png'):
            image_files.append(filename)
    
    deleted_count = 0
    
    for image_file in image_files:
        try:
            # V√©rifier la date de cr√©ation
            file_time = os.path.getctime(image_file)
            if file_time < cutoff_date:
                os.remove(image_file)
                deleted_count += 1
        except:
            continue  # Ignorer les erreurs
    
    return deleted_count

def get_dream_insights(dream_history: List[Dict[str, Any]] = None) -> Dict[str, Any]:
    """G√©n√®re des insights avanc√©s sur les r√™ves"""
    
    if dream_history is None:
        dream_history = load_dream_history()
    
    if not dream_history:
        return {}
    
    insights = {}
    
    # Analyse des patterns temporels
    dates = [datetime.fromisoformat(d["date"]) for d in dream_history]
    
    # Jour de la semaine le plus fr√©quent
    weekdays = [d.weekday() for d in dates]
    weekday_names = ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi", "Dimanche"]
    weekday_counts = {}
    for weekday in weekdays:
        weekday_counts[weekday_names[weekday]] = weekday_counts.get(weekday_names[weekday], 0) + 1
    
    most_common_weekday = max(weekday_counts, key=weekday_counts.get) if weekday_counts else None
    
    # Heure la plus fr√©quente (si disponible)
    hours = [d.hour for d in dates]
    hour_counts = {}
    for hour in hours:
        hour_counts[hour] = hour_counts.get(hour, 0) + 1
    
    most_common_hour = max(hour_counts, key=hour_counts.get) if hour_counts else None
    
    # Corr√©lation entre qualit√© du sommeil et clart√© des r√™ves
    sleep_clarity_pairs = []
    for d in dream_history:
        sleep_q = d["metadata"].get("sleep_quality")
        dream_c = d["metadata"].get("dream_clarity")
        if sleep_q and dream_c:
            sleep_clarity_pairs.append((sleep_q, dream_c))
    
    correlation = 0
    if len(sleep_clarity_pairs) > 1:
        # Calcul simple de corr√©lation
        n = len(sleep_clarity_pairs)
        sum_x = sum(pair[0] for pair in sleep_clarity_pairs)
        sum_y = sum(pair[1] for pair in sleep_clarity_pairs)
        sum_xy = sum(pair[0] * pair[1] for pair in sleep_clarity_pairs)
        sum_x2 = sum(pair[0] ** 2 for pair in sleep_clarity_pairs)
        sum_y2 = sum(pair[1] ** 2 for pair in sleep_clarity_pairs)
        
        numerator = n * sum_xy - sum_x * sum_y
        denominator = ((n * sum_x2 - sum_x ** 2) * (n * sum_y2 - sum_y ** 2)) ** 0.5
        
        if denominator != 0:
            correlation = numerator / denominator
    
    # √âvolution des √©motions dans le temps
    emotion_evolution = {}
    for d in dream_history:
        date_str = d["date"][:10]  # YYYY-MM-DD
        emotions = d["metadata"].get("emotions", [])
        
        if date_str not in emotion_evolution:
            emotion_evolution[date_str] = {}
        
        for emotion in emotions:
            emotion_evolution[date_str][emotion] = emotion_evolution[date_str].get(emotion, 0) + 1
    
    insights = {
        "most_common_weekday": most_common_weekday,
        "most_common_hour": most_common_hour,
        "sleep_clarity_correlation": round(correlation, 3),
        "emotion_evolution": emotion_evolution,
        "total_analysis_period_days": (max(dates) - min(dates)).days if len(dates) > 1 else 0,
        "average_dreams_per_week": calculate_dream_frequency(dates)
    }
    
    return insights

# Fonction utilitaire pour nettoyer les fichiers temporaires
def cleanup_temp_files():
    """Nettoie les fichiers temporaires"""
    temp_files = ["temp_audio.wav"]
    
    for temp_file in temp_files:
        if os.path.exists(temp_file):
            try:
                os.remove(temp_file)
            except:
                pass